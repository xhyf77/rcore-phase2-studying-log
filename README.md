# rcore-phase2-studying-log

### lab1
lab1过的还是比较轻松

### lab2
lab2的mmap和munmap难度不大，同时我踩了一个坑，就是使用gdb调试的时候通过print/x 变量名查看变量的值和直接使用rust的println！来查看变量值发现是不一样的，gdb调试：通过[print/x 变量名]的值并不准确，这可能是因为gdb对rust支持不太好导致的，这也导致我一开始被整的一头雾水，最终在群友陈林峰的帮助下找到了这个原因。

### lab3
lab3的时候使用gdb的debug出了故障，make run能够正常执行，但是make debug却不能，最终发现是由于debug模式下函数调用开销大，内核栈空间爆掉了，因此把内核栈开大一点即可。

### lab4
这个lab4是真的把我坑惨了，原因也是踩了一个玄学坑，lab4的测例很轻松就通过了，但是不知道什么原因，将lab3的spawn系统调用移植过来后，关于spawn的测例一直不给通过，起初，我调试了很久，发现是内存非法访问的问题，之后又继续调试，发现是elf文件读取出了问题，这就奇了怪了，我继续调试也没能找到elf读取为何出了问题，在调试了几天后最终我放弃了，改变了spawn的实现方式，勉强通过了测例。但是在后来发现有个同学和我遇到了同样的问题，经过群友陈林峰的debug，将Cache从数组改为Vec就可以过了，但是到现在仍然不知道为什么改了就可以过，估计和rust某种特性有关。

### lab5
lab5我的参考资料是OS设计精髓那本书
lab5我其实感觉这个死锁检测有点鸡肋，感觉用银行家算法有点大炮打蚊子了，因为我们的请求都是一个一个请求，且没有初始的max矩阵，因此我们只能在发生死锁前最后一刻才能检测到死锁，感觉是没必要使用银行家算法。